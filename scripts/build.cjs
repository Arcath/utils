const path = require('path')
const fs = require('fs')

const FUNCTIONS = path.join(__dirname, '..', 'src', 'functions')
const CLASSES = path.join(__dirname, '..', 'src', 'classes')

const INDEX = path.join(__dirname, '..', 'src', 'index.ts')

const lines = [`// Automatically generated by ./scripts/build.cjs`, '']

fs.readdir(FUNCTIONS, (err, files) => {
  files.forEach(file => {
    if (file.match(`\.spec\.`)) {
      return
    }

    const buff = fs.readFileSync(path.join(FUNCTIONS, file))

    const line = buff.toString().split('\n').slice(-2, -1)[0]

    if (line.match(`// {.*?}`)) {
      lines.push(
        `export {${
          line.match(`// {(.*?)}`)[1]
        }} from './functions/${file.replace('.ts', '')}'`
      )
    } else {
      if (!line.match(`// exclude`)) {
        throw new Error(`functions/${file} has no exports`)
      }
    }
  })

  fs.readdir(CLASSES, (err, files) => {
    files.forEach(file => {
      if (file.match(`\.spec\.`)) {
        return
      }

      const buff = fs.readFileSync(path.join(CLASSES, file))

      const line = buff.toString().split('\n').slice(-2, -1)[0]

      if (line.match(`// {.*?}`)) {
        lines.push(
          `export {${
            line.match(`// {(.*?)}`)[1]
          }} from './classes/${file.replace('.ts', '')}'`
        )
      } else {
        throw new Error(`classes/${file} has no exports`)
      }
    })

    fs.writeFile(INDEX, lines.join(`\r\n`), err => {})
  })
})
